#!/usr/bin/env python3
import os
import time
import json
import logging
import threading
import requests
import sys
from concurrent.futures import ThreadPoolExecutor
from urllib.parse import urlparse
from tqdm import tqdm

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class DownloadManager:
    def __init__(self, url, save_path=None, min_threads=2, max_threads=8, chunk_size=1024*1024, monitor_interval=1):
        self.url = url
        self.filename = os.path.basename(urlparse(url).path) or "downloaded_file"
        self.save_path = save_path or self.filename
        self.min_threads = min_threads
        self.max_threads = max_threads
        self.chunk_size = chunk_size  # Chunk size in bytes
        self.monitor_interval = monitor_interval  # Monitor interval in seconds
        
        self.file_size = 0
        self.downloaded_size = 0
        self.tasks = []
        self.active_tasks = 0
        self.progress_file = f"{self.save_path}.progress"
        self.lock = threading.Lock()
        self.running = False
        self.monitor_thread = None
        self.last_downloaded = 0
        self.current_speed = 0
        self.current_threads = min_threads
        self.progress_bar = None
        
    def get_file_info(self):
        """Get file size and check if range requests are supported"""
        try:
            response = requests.head(self.url, timeout=10)
            response.raise_for_status()
            self.file_size = int(response.headers.get('content-length', 0))
            supports_range = 'bytes' in response.headers.get('accept-ranges', '')
            
            if not supports_range or self.file_size == 0:
                logger.warning("Server doesn't support range requests or file size couldn't be determined. Using single thread.")
                self.max_threads = self.min_threads = 1
                return False
                
            logger.info(f"File size: {self.file_size} bytes, Range requests supported")
            return True
            
        except Exception as e:
            logger.error(f"Failed to get file information: {e}")
            return False
            
    def load_progress(self):
        """Load previous download progress"""
        if not os.path.exists(self.progress_file):
            return False
            
        try:
            with open(self.progress_file, 'r') as f:
                data = json.load(f)
                self.file_size = data['file_size']
                self.tasks = data['tasks']
                self.downloaded_size = sum(task['downloaded'] for task in self.tasks)
                
                # Verify progress file integrity
                total_size = sum(task['end'] - task['start'] + 1 for task in self.tasks)
                if total_size != self.file_size:
                    logger.warning("Progress file does not match file size. Starting download from beginning.")
                    return False
                    
                logger.info(f"Progress loaded: {self.downloaded_size}/{self.file_size} bytes ({(self.downloaded_size/self.file_size*100):.2f}%)")
                return True
                
        except Exception as e:
            logger.error(f"Failed to load progress: {e}")
            return False
            
    def save_progress(self):
        """Save current download progress"""
        with self.lock:
            with open(self.progress_file, 'w') as f:
                data = {
                    'file_size': self.file_size,
                    'tasks': self.tasks
                }
                json.dump(data, f)
                
    def prepare_tasks(self):
        """Prepare download tasks"""
        if not self.load_progress():
            # If no previous progress, create new tasks
            chunk_size = max(self.chunk_size, self.file_size // self.max_threads)
            self.tasks = []
            
            for i in range(0, self.file_size, chunk_size):
                start = i
                end = min(i + chunk_size - 1, self.file_size - 1)
                self.tasks.append({
                    'id': len(self.tasks),
                    'start': start, 
                    'end': end,
                    'downloaded': 0,
                    'completed': False
                })
                
            logger.info(f"Created {len(self.tasks)} download tasks")
            
        # Ensure output file exists
        if not os.path.exists(self.save_path):
            with open(self.save_path, 'wb') as f:
                f.seek(self.file_size - 1)
                f.write(b'\0')
                
    def download_chunk(self, task):
        """Download a single task chunk"""
        task_id = task['id']
        start = task['start'] + task['downloaded']
        end = task['end']
        
        if start > end:
            task['completed'] = True
            return
            
        self.active_tasks += 1
        headers = {'Range': f'bytes={start}-{end}'}
        
        try:
            response = requests.get(self.url, headers=headers, stream=True, timeout=30)
            response.raise_for_status()
            
            with open(self.save_path, 'r+b') as f:
                f.seek(start)
                for chunk in response.iter_content(chunk_size=8192):
                    if not self.running:
                        break
                    if chunk:
                        f.write(chunk)
                        downloaded = len(chunk)
                        with self.lock:
                            task['downloaded'] += downloaded
                            self.downloaded_size += downloaded
                            
            task['completed'] = True
            logger.debug(f"Task {task_id} completed")
            
        except Exception as e:
            logger.error(f"Task {task_id} download failed: {e}")
            
        finally:
            self.active_tasks -= 1
            self.save_progress()
            
    def monitor_progress(self):
        """Monitor download progress and adjust thread count with progress bar"""
        prev_downloaded = self.downloaded_size
        
        # Initialize progress bar
        self.progress_bar = tqdm(
            total=self.file_size,
            initial=self.downloaded_size,
            unit='B',
            unit_scale=True,
            unit_divisor=1024,
            desc=f"Downloading {self.filename}",
            bar_format='{desc}: {percentage:3.1f}%|{bar:30}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}]'
        )
        
        while self.running:
            time.sleep(self.monitor_interval)
            
            # Calculate current download speed
            current_downloaded = self.downloaded_size
            downloaded_diff = current_downloaded - prev_downloaded
            speed = downloaded_diff / self.monitor_interval
            self.current_speed = speed
            
            # Update progress bar
            self.progress_bar.update(downloaded_diff)
            
            # Calculate estimated time remaining
            if speed > 0:
                eta = (self.file_size - current_downloaded) / speed
                eta_min = int(eta // 60)
                eta_sec = int(eta % 60)
                eta_str = f"{eta_min}m {eta_sec}s"
            else:
                eta_str = "unknown"
            
            # Update progress bar description with threads info
            self.progress_bar.set_description(
                f"Downloading {self.filename} | Speed: {speed/1024/1024:.2f} MB/s | Threads: {self.current_threads}"
            )
            
            # Dynamically adjust thread count
            self.adjust_threads(speed, prev_downloaded, current_downloaded)
            
            prev_downloaded = current_downloaded
            
    def adjust_threads(self, speed, prev_downloaded, current_downloaded):
        """Adjust thread count based on download speed"""
        # If speed decreases by more than 25%, reduce threads
        if prev_downloaded > 0 and current_downloaded > prev_downloaded:
            if self.current_threads > self.min_threads and speed < (self.last_downloaded / self.monitor_interval) * 0.75:
                self.current_threads -= 1
                logger.debug(f"Download speed decreased, reducing threads to {self.current_threads}")
                
            # If speed increases by more than 25%, increase threads
            elif self.current_threads < self.max_threads and speed > (self.last_downloaded / self.monitor_interval) * 1.25:
                self.current_threads += 1
                logger.debug(f"Download speed improved, increasing threads to {self.current_threads}")
                
        self.last_downloaded = current_downloaded - prev_downloaded
            
    def start(self):
        """Start download"""
        if not self.get_file_info():
            return False
            
        self.prepare_tasks()
        self.running = True
        
        # Start monitoring thread
        self.monitor_thread = threading.Thread(target=self.monitor_progress)
        self.monitor_thread.daemon = True
        self.monitor_thread.start()
        
        try:
            incomplete_tasks = [task for task in self.tasks if not task['completed']]
            logger.info(f"Starting download, {len(incomplete_tasks)} tasks remaining")
            
            with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
                while self.running and incomplete_tasks:
                    # Limit concurrent tasks based on current thread count
                    active_futures = []
                    
                    # Submit current thread count of tasks
                    for i in range(min(self.current_threads, len(incomplete_tasks))):
                        if i < len(incomplete_tasks):
                            future = executor.submit(self.download_chunk, incomplete_tasks[i])
                            active_futures.append(future)
                            
                    # Wait for this batch to complete
                    for future in active_futures:
                        future.result()
                        
                    # Update incomplete tasks list
                    incomplete_tasks = [task for task in self.tasks if not task['completed']]
                    
            # Check if all tasks are completed
            if all(task['completed'] for task in self.tasks):
                if self.progress_bar:
                    self.progress_bar.close()
                logger.info("Download completed successfully!")
                # Remove progress file
                if os.path.exists(self.progress_file):
                    os.remove(self.progress_file)
                return True
            else:
                if self.progress_bar:
                    self.progress_bar.close()
                logger.warning("Download did not complete")
                return False
                
        except KeyboardInterrupt:
            if self.progress_bar:
                self.progress_bar.close()
            logger.info("Download paused, progress saved")
            self.save_progress()
            return False
            
        finally:
            self.running = False
            if self.monitor_thread:
                self.monitor_thread.join(timeout=1)
            if self.progress_bar:
                self.progress_bar.close()

def main():
    """Main function, handle command line arguments"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Turbo - Efficient multi-threaded downloader')
    parser.add_argument('url', help='URL of the file to download')
    parser.add_argument('-o', '--output', help='Output file path')
    parser.add_argument('--min-threads', type=int, default=2, help='Minimum number of threads')
    parser.add_argument('--max-threads', type=int, default=8, help='Maximum number of threads')
    
    args = parser.parse_args()
    
    manager = DownloadManager(
        url=args.url,
        save_path=args.output,
        min_threads=args.min_threads, 
        max_threads=args.max_threads
    )
    
    success = manager.start()
    return 0 if success else 1

if __name__ == "__main__":
    sys.exit(main())
